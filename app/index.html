<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>ai_tof</title>
    <link rel="stylesheet" href="./css/reset.css" />
  </head>
  <body>
    <video id="video" autoplay=""></video>
    <canvas id="imgCanvas"></canvas>
    <canvas id="canvas"></canvas>
    <p id="width"></p>
    <p id="height"></p>
  </body>
  <script src="./js/tf.js"></script>
  <!-- Load the coco-ssd model. -->
  <script src="./js/coco-ssd.js"></script>

  <script type="text/javascript">
    let model
    const w = document.body.clientWidth
    const h = document.body.clientHeight
    const w1,h1;

    const btn = document.getElementById('tap')
    const video = document.getElementById('video')
    const canvas = document.getElementById('canvas')
    const iCanvas = document.getElementById('imgCanvas')

    video.width = w
    video.height = h
    canvas.width = w
    canvas.height = h
    iCanvas.width = w
    iCanvas.height = h

    btn.addEventListener('click', handleClick)

    function handleClick() {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const webCamPromise = navigator.mediaDevices
          .getUserMedia({
            audio: false,
            video: {
              // width:1920,
              // height:1280,
              // facingMode: 'user'
              facingMode:'environment' 
            }
          })
          .then(stream => {
            window.stream = stream
            video.srcObject = stream
            let videoTrack = stream.getVideoTracks()[0]
            console.log(videoTrack)
            // 通过 videotrack 的getsettings 拿到constrants的对象
            let videoConstraints = videoTrack.getSettings()
            document.getElementById('width').innerHTML = videoConstraints.width;
            document.getElementById('height').innerHTML = videoConstraints.height;

            return new Promise((resolve, reject) => {
              video.onloadedmetadata = () => {
                resolve()
              }
            })
          })
        const modelPromise = cocoSsd.load()
        Promise.all([modelPromise, webCamPromise])
          .then(values => {
            detectFrame(video, values[0])
          })
          .catch(error => {
            console.error(error)
          })
      }
    }

    detectFrame = (video, model) => {
      model.detect(video).then(predictions => {
        renderPredictions(predictions);
        requestAnimationFrame(() => {
          detectFrame(video, model)
        })
      })
    }

    function renderPredictions(predictions) {
      const ctx = canvas.getContext('2d')
      ctx.clearRect(0, 0, w, h)
      // Font options.
      const font = '16px sans-serif'
      ctx.font = font
      ctx.textBaseline = 'top'
      predictions.forEach(prediction => {
        const [x,y,cw,ch] = prediction.bbox;
        ctx.strokeStyle = '#00FFFF'
        ctx.lineWidth = 4
        ctx.strokeRect(x, y, cw, ch)
        // Draw the label background.
        ctx.fillStyle = '#00FFFF'
        const textWidth = ctx.measureText(prediction.class).width
        const textHeight = parseInt(font, 10) // base 10
        ctx.fillRect(x, y, textWidth + 4, textHeight + 4)
      })

      predictions.forEach(prediction => {
        const x = prediction.bbox[0]
        const y = prediction.bbox[1]
        ctx.fillStyle = '#000000'
        ctx.fillText(prediction.class, x, y)
      })
    }
  </script>
</html>
